import lib.std
import lib.std.math


const WIDTH   160
const HEIGHT  90

const FOCAL_LENGTH 90

buffer ray_origin     24
buffer ray_direction  24
buffer ray_color      24


buffer _sphere_dist_buffer 24

def sphere_dist: int center_x, int center_y, int center_z, int radius -> int
    # Returns the distance of the current ray to a given sphere
    center_x _sphere_dist_buffer vec.x + seti
    center_y _sphere_dist_buffer vec.y + seti
    center_z _sphere_dist_buffer vec.z + seti

    _sphere_dist_buffer ray_origin _sphere_dist_buffer vec_sub
    _sphere_dist_buffer ray_direction _sphere_dist_buffer vec_sub

    _sphere_dist_buffer vec_len radius -


def generate_camera_ray: int x, int y -> void
    # Set ray origin to (0, 0, 0)
    0 ray_origin vec.x + seti
    0 ray_origin vec.y + seti
    0 ray_origin vec.z + seti

    # Set the ray direction:
    # ray_direction.x = x - WIDTH/2
    # ray_direction.y = HEIGHT/2 - y
    # ray_direction.z = -FOCAL_LENGTH
    x WIDTH 2 div -  ray_direction vec.x + seti
    HEIGHT 2 div y - ray_direction vec.y + seti
    0 FOCAL_LENGTH - ray_direction vec.z + seti

    # Normalize vector
    ray_direction dup vec_unit


def calculate_sky_color: int t -> void
    1000 t - t 2 div + 256 * 1000 div ray_color vec.x + seti
    1000 t - t 7 * 10 div + 256 * 1000 div ray_color vec.y + seti
    256 ray_color vec.z + seti


buffer closest_object_distance 8  # int
buffer closest_object_material 8  # int
buffer normal_vector 24

const MATERIAL_SKY 0
const MATERIAL_RED 1
const MATERIAL_GREEN 2
const MATERIAL_BLUE 3

def check_sphere: int center_x, int center_y, int center_z, int radius, int material -> void
    # Check if a given sphere is closest and update globals accordingly
    center_x center_y center_z radius sphere_dist
    dup closest_object_distance derefi < if
        dup closest_object_distance seti
        material closest_object_material seti

        center_x 8 - center_y center_z radius sphere_dist
        center_x 8 + center_y center_z radius sphere_dist - normal_vector vec.x + seti
        center_x center_y 8 - center_z radius sphere_dist
        center_x center_y 8 + center_z radius sphere_dist - normal_vector vec.y + seti
        center_x center_y center_z 8 - radius sphere_dist
        center_x center_y center_z 8 + radius sphere_dist - normal_vector vec.z + seti
        normal_vector dup vec_unit


def find_closest_object: -> void
    10000         closest_object_distance seti
    MATERIAL_SKY  closest_object_material seti

    0 0 0 4200 - 1234 MATERIAL_RED check_sphere
    1515 250 0 2989 - 420 MATERIAL_BLUE check_sphere
    0 1234 - 0 400 - 0 2989 - 280 MATERIAL_GREEN check_sphere


buffer hit 1
buffer steps 8
buffer _march_buffer 24

def march: -> void
    # Will raymarch until something is hit or z is less than -20000
    # Sets a new ray when something is hit.

    False hit setb
    0 steps seti

    while hit derefb False = \
          ray_origin vec.z + derefi 0 20000 - > and \
          steps derefi 1000 < and
        # Increment steps
        steps derefi 1 + steps seti

        # Fetch closest object
        find_closest_object

        # Check for hit
        closest_object_distance derefi 10 < if
            True hit setb

        # Update ray origin
        ray_direction closest_object_distance derefi _march_buffer vec_mul
        _march_buffer 1000 _march_buffer vec_div
        ray_origin _march_buffer ray_origin vec_add

    hit derefb if
        # TODO: update ray on hit


def calculate_ray_color: -> void
    march
    hit derefb False = closest_object_material derefi MATERIAL_SKY = or if
        ray_direction vec.y + derefi 1000 + 2 div calculate_sky_color
    elif closest_object_material derefi MATERIAL_RED =
        255 normal_vector vec.y + derefi 1000 + * 1500 div ray_color vec.x + seti
        0 ray_color vec.y + seti
        0 ray_color vec.z + seti
    elif closest_object_material derefi MATERIAL_GREEN =
        0 ray_color vec.x + seti
        255 normal_vector vec.y + derefi 1000 + * 1500 div ray_color vec.y + seti
        0 ray_color vec.z + seti
    elif closest_object_material derefi MATERIAL_BLUE =
        0 ray_color vec.x + seti
        0 ray_color vec.y + seti
        255 normal_vector vec.y + derefi 1000 + * 1500 div ray_color vec.z + seti
    else
        "Unknown material!" raise


def print_ray_color: -> void
    ray_color vec.x + derefi itos puts " " puts
    ray_color vec.y + derefi itos puts " " puts
    ray_color vec.z + derefi itos puts " " puts


def draw_pixel: int x, int y -> void
    x y generate_camera_ray
    calculate_ray_color
    print_ray_color


def main: ptr argv, int argc -> int
    # Print PPM metadata
    "P3 " puts
    WIDTH itos puts " " puts
    HEIGHT itos puts " " puts
    "256\n" puts

    # Render image
    0
    while dup HEIGHT <
        0
        while dup WIDTH <
            over over swap draw_pixel
            1 +
        drop
        1 +

        "\n" puts
    0
