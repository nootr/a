import lib.std
import lib.ilo.constants
import lib.ilo.lexer
import lib.ilo.opcodes
import lib.ilo.tokens
import lib.ilo.types


buffer _if_index     8  # int
buffer _while_index  8  # int
buffer _token_index  8  # int
buffer _type_stack   8  # ptr
buffer _buffers      8  # ptr
buffer _constants    8  # ptr
buffer _opcodes      8  # ptr
buffer _files        8  # ptr


def _type_error: int line, ptr message -> void
    # Raises a type error
    "Type error on line " error
    line                  errori
    ": "                  error
    message               error
    "\n"                  error
    1 exit


def _peek_next_token: ptr tokens -> ptr
    # Returns the next token without increasing the token index
    _token_index derefi tokens list.len + derefi < if
        _token_index derefi tokens list_fetch
    else
        NULL


def _get_next_token: ptr tokens -> ptr
    # Returns the next token while increasing the token index
    _token_index derefi tokens list.len + derefi < if
        _token_index derefi dup tokens list_fetch
        swap 1 + _token_index seti
    else
        NULL


def _push_type: int type -> void
    # Pushes a given type to the type stack
    type _type_stack derefp list_append_int _type_stack setp


def _pop_type: int line -> int
    # Pops and returns a type from the type stack
    _type_stack derefp list.len + derefi 0 = if
        line "Not enough values on the stack" _type_error
    _type_stack derefp list_pop_int


def _file_has_been_imported: ptr file -> bool
    # Returns True if file has already been imported
    False
    0
    while dup _files derefp list.len + derefi <
        dup _files derefp list_fetch_int castp file streq if
            swap drop True swap
        1 +
    drop
    dup False = if
        file casti _files derefp list_append_int _files setp


def parse: ptr filename, ptr tokens -> ptr
    # Parses a given tokenlist and returns a list of opcodes

    # Initialize globals
    _if_index derefi 0 = if
        1 _if_index seti

    _while_index derefi 0 = if
        1 _while_index seti

    _type_stack derefp NULL = if
        INT_SIZE new_list _type_stack setp

    _buffers derefp NULL = if
        PTR_SIZE new_list _buffers setp

    _constants derefp NULL = if
        CONSTANT_SIZE new_list _constants setp

    _opcodes derefp NULL = if
        OPCODE_SIZE new_list _opcodes setp

    _files derefp NULL = if
        PTR_SIZE new_list _files setp
        filename casti _files derefp list_append_int _files setp

    while tokens _peek_next_token token.type + derefi TOKEN_END !=
        tokens _get_next_token

        dup token.type + derefi TOKEN_BOOL = if
            OPCODE_PUSH_BOOL
            over dup token.value + derefp
            swap token.line + derefi
            _opcodes derefp create_opcode _opcodes setp

            TYPE_BOOL _push_type
        elif dup token.type + derefi TOKEN_CHAR =
            OPCODE_PUSH_CHAR
            over dup token.value + derefp
            swap token.line + derefi
            _opcodes derefp create_opcode _opcodes setp

            TYPE_CHAR _push_type
        elif dup token.type + derefi TOKEN_INT =
            OPCODE_PUSH_INT
            over dup token.value + derefp
            swap token.line + derefi
            _opcodes derefp create_opcode _opcodes setp

            TYPE_INT _push_type
        elif dup token.type + derefi TOKEN_STRING =
            OPCODE_PUSH_STRING
            over dup token.value + derefp
            swap token.line + derefi
            _opcodes derefp create_opcode _opcodes setp

            TYPE_PTR _push_type
        elif dup token.type + derefi TOKEN_ARITHMETIC =
            dup token.value + derefp "+" streq if
                OPCODE_ADD
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type
                dup TYPE_INT != over TYPE_PTR != and if
                    over token.line + derefi
                    "Only integers and pointers could be added" _type_error

                over token.line + derefi _pop_type
                dup TYPE_INT != over TYPE_PTR != and if
                    rot token.line + derefi
                    "Only integers and pointers could be added" _type_error
                    NULL rot rot

                TYPE_PTR = swap TYPE_PTR = or if
                    TYPE_PTR _push_type
                else
                    TYPE_INT _push_type
            elif dup token.value + derefp "-" streq
                OPCODE_SUBTRACT
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type TYPE_INT != if
                    dup token.line + derefi
                    "Second type in subtract must be an integer" _type_error

                dup token.line + derefi _pop_type
                dup dup TYPE_INT != swap TYPE_PTR != and if
                    over token.line + derefi
                    "Only integers and pointers can be subtracted" _type_error

                _push_type
            elif dup token.value + derefp "*" streq
                OPCODE_MULTIPLY
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup  token.line + derefi _pop_type TYPE_INT !=
                over token.line + derefi _pop_type TYPE_INT != or if
                    dup token.line + derefi
                    "Can't multiply non-integer" _type_error

                TYPE_INT _push_type
            elif dup token.value + derefp "and" streq
                OPCODE_BITWISE_AND
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type
                dup TYPE_INT != over TYPE_BOOL != and if
                    over token.line + derefi
                    "Need integers or booleans for bitwise and" _type_error
                over token.line + derefi _pop_type != if
                    dup token.line + derefi
                    "Bitwise and needs two similar types as input" _type_error

                TYPE_BOOL _push_type
            elif dup token.value + derefp "or" streq
                OPCODE_BITWISE_OR
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type
                dup TYPE_INT != over TYPE_BOOL != and if
                    over token.line + derefi
                    "Need integers or booleans for bitwise or" _type_error
                over token.line + derefi _pop_type != if
                    dup token.line + derefi
                    "Bitwise or needs two similar types as input" _type_error

                TYPE_BOOL _push_type
            elif dup token.value + derefp "shr" streq
                OPCODE_SHIFT_RIGHT
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup  token.line + derefi _pop_type TYPE_INT !=
                over token.line + derefi _pop_type TYPE_INT != or if
                    dup token.line + derefi
                    "Can't shift non-integer" _type_error

                TYPE_INT _push_type
            elif dup token.value + derefp "shl" streq
                OPCODE_SHIFT_LEFT
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup  token.line + derefi _pop_type TYPE_INT !=
                over token.line + derefi _pop_type TYPE_INT != or if
                    dup token.line + derefi
                    "Can't shift non-integer" _type_error

                TYPE_INT _push_type
            else
                "Unknown value for arithmetic token: "
                over token.value + derefp concat
                raise
        elif dup token.type + derefi TOKEN_COMPARISON =
            dup token.value + derefp "=" streq if
                OPCODE_IS_EQUAL
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp
            elif dup token.value + derefp "!=" streq
                OPCODE_IS_NOT_EQUAL
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp
            elif dup token.value + derefp ">=" streq
                OPCODE_IS_GREATER_OR_EQUAL
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp
            elif dup token.value + derefp "<=" streq
                OPCODE_IS_LESS_OR_EQUAL
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp
            elif dup token.value + derefp ">" streq
                OPCODE_IS_GREATER
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp
            elif dup token.value + derefp "<" streq
                OPCODE_IS_LESS
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp
            else
                "Unknown comparison token: "
                over token.value + derefp concat
                raise

            dup token.line + derefi _pop_type
            over token.line + derefi _pop_type != if
                dup token.line + derefi
                "Comparison between different types" _type_error

            TYPE_BOOL _push_type
        elif dup token.type + derefi TOKEN_KEYWORD =
            dup token.value + derefp "debug" streq if
                "Stack: " puts
                0  # index
                while dup _type_stack derefp list.len + derefi <
                    dup _type_stack derefp list_fetch_int type_to_str puts
                    " " puts
                    1 +
                drop
                "\n" puts
                0 exit
            elif dup token.value + derefp "import" streq
                drop
                tokens _get_next_token
                dup token.type + derefi TOKEN_IDENTIFIER != if
                    dup token.line + derefi
                    "Expected identifier after import keyword" _type_error

                dup token.value + derefp '.' '/' replace ".ilo" concat
                dup _file_has_been_imported False = if
                    dup dup read_file tokenize parse drop
                drop
            elif dup token.value + derefp "location" streq
                # TODO: Implement this as soon as we've got a better int to str function
                "The location keyword is not implemented yet" raise
            elif dup token.value + derefp "castb" streq
                dup token.line + derefi _pop_type drop
                TYPE_BOOL _push_type
            elif dup token.value + derefp "castc" streq
                dup token.line + derefi _pop_type drop
                TYPE_CHAR _push_type
            elif dup token.value + derefp "casti" streq
                dup token.line + derefi _pop_type drop
                TYPE_INT _push_type
            elif dup token.value + derefp "castp" streq
                dup token.line + derefi _pop_type drop
                TYPE_PTR _push_type
            elif dup token.value + derefp "dup" streq
                OPCODE_DUP
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type
                dup _push_type _push_type
            elif dup token.value + derefp "drop" streq
                OPCODE_DROP
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type drop
            elif dup token.value + derefp "rot" streq
                OPCODE_ROT
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type
                swap dup token.line + derefi _pop_type
                swap dup token.line + derefi _pop_type
                rot _push_type rot _push_type _push_type
            elif dup token.value + derefp "swap" streq
                OPCODE_SWAP
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type
                over token.line + derefi _pop_type
                swap _push_type _push_type
            elif dup token.value + derefp "over" streq
                OPCODE_OVER
                over token.line + derefi
                NULL swap
                _opcodes derefp create_opcode _opcodes setp

                dup token.line + derefi _pop_type
                over token.line + derefi _pop_type
                dup _push_type swap _push_type _push_type
            elif dup token.value + derefp "syscall" streq
                drop
                tokens _get_next_token
                dup token.type + derefi TOKEN_INT != if
                    dup token.line + derefi
                    "Syscall is missing argument count"
                    _type_error

                dup dup token.value + derefp
                swap token.line + derefi
                OPCODE_SYSCALL
                rot rot
                _opcodes derefp create_opcode _opcodes setp

                dup token.value + derefp stoi
                while dup 0 >
                    over token.line + derefi _pop_type drop
                    1 -
                drop
                TYPE_INT _push_type
            else
                "Unknown keyword: " over token.value + derefp concat raise
        elif dup token.type + derefi TOKEN_TYPE =
            dup token.line + derefi "Unexpected type" _type_error
        else
            "Unknown token type: "
            over token.type + derefi token_to_str concat
            raise

        drop

        tokens _peek_next_token NULL != "Token list should end with END token" assert

    _opcodes derefp
