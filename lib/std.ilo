const BOOL_SIZE 1
const CHAR_SIZE 1
const INT_SIZE  8
const PTR_SIZE  8

const STDIN  0
const STDOUT 1
const STDERR 2

const SYS_READ   0
const SYS_WRITE  1
const SYS_OPEN   2
const SYS_MMAP   9
const SYS_MUNMAP 11
const SYS_EXIT   60

const O_RDONLY      0
const O_WRONLY      1
const PROT_READ     1
const PROT_WRITE    2
const MAP_PRIVATE   2
const MAP_ANONYMOUS 32


def NULL: -> ptr
    # Returns a null-pointer
    0 castp


def memcpy: ptr src, ptr dest, int num -> void
    # Copies a given amount of bytes from src to dest
    0
    while dup num <
        dup src + derefc
        over dest + setc
        1 +


def i64tohex: int x, ptr buf -> void
    # Converts a given 64-bit integer to its hexadecimal representation
    buf
    dup '0' swap setc 1 +
    dup 'x' swap setc 1 +

    60  # offset
    while dup 0 >=
        dup
        15 swap shl
        x and
        swap dup rot swap shr

        dup 0 = if
            rot dup '0' swap setc rot rot
        elif dup 1 =
            rot dup '1' swap setc rot rot
        elif dup 2 =
            rot dup '2' swap setc rot rot
        elif dup 3 =
            rot dup '3' swap setc rot rot
        elif dup 4 =
            rot dup '4' swap setc rot rot
        elif dup 5 =
            rot dup '5' swap setc rot rot
        elif dup 6 =
            rot dup '6' swap setc rot rot
        elif dup 7 =
            rot dup '7' swap setc rot rot
        elif dup 8 =
            rot dup '8' swap setc rot rot
        elif dup 9 =
            rot dup '9' swap setc rot rot
        elif dup 10 =
            rot dup 'a' swap setc rot rot
        elif dup 11 =
            rot dup 'b' swap setc rot rot
        elif dup 12 =
            rot dup 'c' swap setc rot rot
        elif dup 13 =
            rot dup 'd' swap setc rot rot
        elif dup 14 =
            rot dup 'e' swap setc rot rot
        elif dup 15 =
            rot dup 'f' swap setc rot rot
        drop 4 - swap 1 + swap
    drop 0 castc swap setc


def i8tohex: int x, ptr buf -> void
    # Converts a given 8-bit integer to its hexadecimal representation
    buf
    dup '0' swap setc 1 +
    dup 'x' swap setc 1 +

    4  # offset
    while dup 0 >=
        dup
        15 swap shl
        x and
        swap dup rot swap shr

        dup 0 = if
            rot dup '0' swap setc rot rot
        elif dup 1 =
            rot dup '1' swap setc rot rot
        elif dup 2 =
            rot dup '2' swap setc rot rot
        elif dup 3 =
            rot dup '3' swap setc rot rot
        elif dup 4 =
            rot dup '4' swap setc rot rot
        elif dup 5 =
            rot dup '5' swap setc rot rot
        elif dup 6 =
            rot dup '6' swap setc rot rot
        elif dup 7 =
            rot dup '7' swap setc rot rot
        elif dup 8 =
            rot dup '8' swap setc rot rot
        elif dup 9 =
            rot dup '9' swap setc rot rot
        elif dup 10 =
            rot dup 'a' swap setc rot rot
        elif dup 11 =
            rot dup 'b' swap setc rot rot
        elif dup 12 =
            rot dup 'c' swap setc rot rot
        elif dup 13 =
            rot dup 'd' swap setc rot rot
        elif dup 14 =
            rot dup 'e' swap setc rot rot
        elif dup 15 =
            rot dup 'f' swap setc rot rot
        drop 4 - swap 1 + swap
    drop 0 castc swap setc


def i64tos: int x, ptr buf -> void
    # Converts a given 64-bit integer to string
    buf
    dup '0' swap setc 1 +
    dup 'b' swap setc 1 +

    1 63 shl  # Sweeping bit
    while dup 0 !=
        swap dup rot dup
        x and 0 != if
            '1' rot setc swap 1 + swap
        else
            '0' rot setc swap 1 + swap
        1 shr
    drop 0 castc swap setc


def i8tos: int x, ptr buf -> void
    # Converts a given 8-bit integer to string
    buf
    dup '0' swap setc 1 +
    dup 'b' swap setc 1 +

    1 7 shl  # Sweeping bit
    while dup 0 >
        swap dup rot dup
        x and 0 != if
            '1' rot setc swap 1 + swap
        else
            '0' rot setc swap 1 + swap
        1 shr
    drop 0 castc swap setc


def max: int x, int y -> int
    # Returns the largest number
    x y > if
        x
    else
        y


def strlen: ptr s -> int
    # Returns the length of a given zero-terminated string
    0  # Counter
    while dup s + derefc 0 castc !=
        1 +


def strcpy: ptr src, ptr dest -> ptr
    # Copies a string from src to dest and returns a pointer to dest
    0  # index
    while dup src + derefc 0 castc !=
        dup src + derefc over dest + setc
        1 +
    dest + 0 castc swap setc
    dest


def startswith: ptr s, ptr q -> bool
    # Returns True if str s starts with substring q
    q strlen s strlen <= if
        False # found_difference
        0     # index
        while dup q + derefc 0 castc !=
            dup q + derefc
            over s + derefc !=
            rot or swap
            1 +
        drop
        False =
    else
        False


def puts: ptr s -> void
    # Prints a string and returns the write syscall exit-code
    STDOUT     # File descriptor
    s          # Pointer to string
    s strlen   # String length
    SYS_WRITE
    syscall 3


def error: ptr s -> void
    # Prints an error and returns the write syscall exit-code
    STDERR     # File descriptor
    s          # Pointer to string
    s strlen   # String length
    SYS_WRITE
    syscall 3


def exit: int code -> void
    # Exits using a given exit code
    code SYS_EXIT syscall 1


def raise: ptr message -> void
    # Prints a given error message and exits with exitcode 1
    "Error: " error
    message   error
    "\n"      error
    1 exit


def assert: bool assertion, ptr message -> void
    # Raises when assertion is False
    assertion False = if
        message raise


def open: ptr filename, char mode -> int
    # Opens a given file in (r)ead or (w)rite mode and returns a file descriptor.
    filename
    0

    mode 'r' = if
        O_RDONLY or
    mode 'w' = if
        O_WRONLY or

    0
    SYS_OPEN
    syscall 3

    dup 0 < if
        "Could not open file" raise


def read: int fd, ptr buf, int count -> int
    # Reads from a file descriptor and returns the number of bytes read or zero if EOF
    fd buf count SYS_READ syscall 3
    dup 0 < if
        "Could not read file" raise


const page.next          0   # ptr
const page.prev          8   # ptr
const page.size          16  # int
const page.blocks        24  # ptr
const PAGE_METADATA_SIZE 24

const PAGE_SIZE          4096

const block.next          0   # ptr
const block.prev          8   # ptr
const block.size          16  # integer
const block.free          24  # boolean
const block.data          25  # data
const BLOCK_METADATA_SIZE 25

buffer root_page 8


buffer VERIFY_MEMORY 1  # Set to True to verify memory
buffer DUMP_MEMORY   1  # Set to True to dump dynamically allocated memory

buffer _vm_buf 19

def verify_memory: -> void
    # Checks all the dynamically allocated memory for invalid metadata
    VERIFY_MEMORY derefb if
        DUMP_MEMORY derefb if
            "Verifying memory..\n" puts

        root_page
        while dup page.next + derefp NULL !=
            dup page.next + derefp

            DUMP_MEMORY derefb if
                "* Page: "                          puts
                dup casti _vm_buf i64tohex _vm_buf  puts
                "\n"                                puts

                "  * prev: "                                    puts
                dup page.prev + derefi _vm_buf i64tohex _vm_buf puts
                "\n"                                            puts

                "  * next: "                                    puts
                dup page.next + derefi _vm_buf i64tohex _vm_buf puts
                "\n"                                            puts

                "  * size: "                                    puts
                dup page.size + derefi _vm_buf i64tohex _vm_buf puts
                "\n"                                            puts

            swap over page.prev + derefp = \
                "Pointer to previous page should be valid" assert
            dup page.size + derefi PAGE_SIZE >= \
                "Page size should be at least the default value" assert

            dup page.size + derefi PAGE_METADATA_SIZE -  # Save page size to stack
            over page.blocks +
            while dup NULL !=
                DUMP_MEMORY derefb if
                    "  * block: "                       puts
                    dup casti _vm_buf i64tohex _vm_buf  puts
                    "\n"                                puts

                    "    * size: "                                   puts
                    dup block.size + derefi _vm_buf i64tohex _vm_buf puts
                    "\n"                                             puts

                    "    * next: "                                   puts
                    dup block.next + derefi _vm_buf i64tohex _vm_buf puts
                    "\n"                                             puts

                    "    * prev: "                                   puts
                    dup block.prev + derefi _vm_buf i64tohex _vm_buf puts
                    "\n"                                             puts

                    "    * free: " puts
                    dup block.free + derefb if
                        "True\n" puts
                    else
                        "False\n" puts

                dup block.size + derefi BLOCK_METADATA_SIZE +
                rot swap -
                dup 0 >= "Blocks should not overflow page memory" assert
                swap

                block.next + derefp
            drop

            dup 0 > if
                DUMP_MEMORY derefb if
                    "  * unused bytes: "          puts
                    dup _vm_buf i64tohex _vm_buf  puts
                    "\n"                          puts
                False "Block sizes should sum up to page size" assert
            drop

        drop
        DUMP_MEMORY derefb if
            "Memory OK\n" puts


def _malloc_get_next_page: ptr page, int size -> ptr
    # Returns the next page, creates a new page if there are none
    size PAGE_SIZE >= "Page size should be at least the default size" assert

    page page.next + derefp NULL = if
        NULL                          # addr; kernel chooses position in memory
        size                          # length; (common page size is 4k)
        PROT_READ PROT_WRITE or       # prot; allow read and write
        MAP_PRIVATE MAP_ANONYMOUS or  # flags
        0 1 -                         # fd; -1 is needed for MAP_ANONYMOUS
        0                             # offset; should be 0 for MAP_ANONYMOUS
        SYS_MMAP
        syscall 6

        dup 0 < if
            "Unable to allocate memory page" raise

        castp

        # Initialize page
        dup page.next +                               NULL swap setp
        dup page.prev +                               page swap setp
        dup page.size +                               size swap seti

        # Initialize block
        dup page.blocks +
        dup block.free +                              True swap setb
        dup block.next +                              NULL swap setp
        dup block.prev +                              NULL swap setp
        dup block.size + size PAGE_METADATA_SIZE - \
                         BLOCK_METADATA_SIZE -             swap seti
        drop

        page page.next + setp

    # Return next page
    page page.next + derefp

    dup NULL != "Next page should not be NULL" assert


def _malloc_split_block: ptr block, int old_size, int size -> ptr
    # Splits a free block into a taken and a free block and returns a pointer to the
    # first, taken block.
    block block.free + derefb "Splitted block should be free" assert

    block block.next + derefp  # Save pointer to next block on the stack

    False  block block.free + setb

    # Calculate remaining size of free block
    old_size BLOCK_METADATA_SIZE - size -

    dup 0 > if
        # Only set block size if split actually occurs
        size block block.size + seti

        block BLOCK_METADATA_SIZE + size + block block.next + setp

        True     block block.next + derefp block.free + setb
        block    block block.next + derefp block.prev + setp
        dup      block block.next + derefp block.size + seti
        over     block block.next + derefp block.next + setp

    block


def _malloc_block_is_available_or_NULL: ptr block, int size -> bool
    # Returns True if given block is free and has enough space, or it's a NULL pointer
    block NULL = if
        True
    else
        block block.free + derefb
        block block.size + derefi size >= and


def malloc: int size -> ptr
    # Allocates a memory block of given size and returns its address

    # TODO: Test edge cases

    root_page NULL != "Root page should exist" assert
    size 0 = if
        "Size should be greater than zero" raise

    root_page   # var: current_page
    NULL        # var: available_block

    # Find the next available block
    while dup NULL =
        drop

        # current_page = get_next_page()
        size PAGE_METADATA_SIZE + BLOCK_METADATA_SIZE + \
            PAGE_SIZE max _malloc_get_next_page

        root_page page.next + derefp NULL != "First page should be set" assert
        dup root_page != "Page should not be root page" assert
        dup NULL != "Next page should be set" assert

        # current_block = current_page.blocks[0]
        dup page.blocks +

        dup block.size + derefi 0 != "Block size should be greater than zero" assert

        # Find next available block or NULL (no available blocks in this page)
        while dup size _malloc_block_is_available_or_NULL False =
            block.next + derefp

    dup NULL != "Pointer to found block should be non-NULL" assert
    dup block.free + derefb "Found block should be free" assert

    dup block.size + derefi size = if
        # The block is a perfect fit
        dup block.free + False swap setb
    else
        # The block not is a perfect fit, split into a taken and a free block
        dup block.size + derefi size _malloc_split_block

    block.data +
    verify_memory


def free: ptr block_data -> void
    # Frees a given block

    block_data block.data -

    dup block.free + derefb if
        "Trying to free already freed data" raise

    dup block.free + True swap setb

    dup block.next + derefp NULL != if
        dup block.next + derefp block.free + derefb if
            # Next block is free; merge
            dup block.next + derefp block.size + derefi BLOCK_METADATA_SIZE +
            swap dup rot swap block.size + derefi +
            swap dup rot swap block.size + seti

            dup block.next + derefp block.next + derefp
            swap dup rot swap block.next + setp

            dup block.prev + derefp NULL !=
            over block.next + derefp NULL != and if
                dup
                dup block.next + derefp block.prev + setp # <--

    dup block.prev + derefp NULL != if
        dup block.prev + derefp block.free + derefb if
            # Previous block is free; merge
            dup block.prev + derefp block.size + derefi
            swap dup rot swap block.size + derefi + BLOCK_METADATA_SIZE +
            swap dup rot swap block.prev + derefp block.size + seti

            dup block.next + derefp
            swap dup rot swap block.prev + derefp block.next + setp

            dup block.next + derefp NULL != if
                dup block.prev + derefp
                swap dup rot swap block.next + derefp block.prev + setp

    # Find the first block
    while dup block.prev + derefp NULL !=
        dup block.prev + derefp over < "Previous block should be earlier" assert
        dup dup block.prev + derefi - PAGE_SIZE castp < \
            "Previous block should be within the same page" assert

        block.prev + derefp

    dup block.next + derefp NULL = if
        # This page only has one free block; free/munmap it
        PAGE_METADATA_SIZE -
        dup page.next + derefp
        swap dup rot swap page.prev + derefp page.next + setp

        dup page.next + derefp NULL != if
            dup page.prev + derefp
            swap dup rot swap page.next + derefp page.prev + setp

        dup                    # addr; kernel chooses position in memory
        dup page.size + derefi # length; (common page size is 4k)
        SYS_MUNMAP
        syscall 2

        0 < if
            "Unable to free memory page" raise

    verify_memory


def concat: ptr a, ptr b -> ptr
    # Takes two string and returns them after being concatenated.
    # Note that this mallocs, so don't forget to free!
    a strlen b strlen + 1 + malloc
    a swap strcpy
    dup a strlen + b swap strcpy drop
    dup a strlen + b strlen + 1 + 0 castc swap setc


buffer _read_file_buffer 513

def read_file: ptr filename -> ptr
    # Returns the contents of a given file
    1 malloc
    dup 0 castc swap setc
    filename 'r' open

    1 while dup 0 >
        drop
        dup _read_file_buffer 512 read
        dup _read_file_buffer + 0 castc swap setc
        dup 0 > if
            rot dup _read_file_buffer concat
            swap free
            rot rot
    drop drop


def get_argument: ptr argv, int n -> ptr
    # Takes a list of arguments argv and returns the n'th argument
    argv 0 while dup n <
        swap dup strlen + 1 + swap
        1 +
    drop


def _r13: ptr s -> ptr
    # Applies rot13 to all characters of string s and returns the same pointer.
    s
    dup
    while dup derefc 0 castc !=
        dup derefc ' ' != if
            dup derefc casti 13 +
            dup 'z' casti > if
                26 -
            castc over setc
        1 +
    drop


def zen: -> void
    # Prints the Zen of Ilo, inspired by Python's `import this`
    "anfva cban vyb gna wna ahgh"                                    _r13 puts "\n" puts
    ""                                                               _r13 puts "\n" puts
    "sha vf gur tbny"                                                _r13 puts "\n" puts
    ""                                                               _r13 puts "\n" puts
    "yrneavat vf sha"                                                _r13 puts "\n" puts
    "ohg arrqf zbgvingvba"                                           _r13 puts "\n" puts
    "na vzcerffvir ernpunoyr tbny vf n zbgvingvba"                   _r13 puts "\n" puts
    "jevgvat n cebtenzzvat ynathntr pbhyq or vzcerffvir"             _r13 puts "\n" puts
    "jevgvat n frys ubfgrq pbzcvyre vf vzcerffvir"                   _r13 puts "\n" puts
    ""                                                               _r13 puts "\n" puts
    "orvat sbeprq gb gnpxyr ceboyrzf va n arj jnl vf sha"            _r13 puts "\n" puts
    "vs vgf cenpgvpny rabhtu gb or ghearq vagb fbzrguvat hfrshy"     _r13 puts "\n" puts
    ""                                                               _r13 puts "\n" puts
    "jrveq flagnk vf sha"                                            _r13 puts "\n" puts
    "haernqnoyr pbqr vfag sha"                                       _r13 puts "\n" puts
    ""                                                               _r13 puts "\n" puts
    "bcgvzvmngvbaf nerag sha"                                        _r13 puts "\n" puts
    "nhgbzvmvat bcgvzvmngvbaf pbhyq or sha"                          _r13 puts "\n" puts


def substring: ptr s, int n -> ptr
    # Creates a null-terminated substring of the first n bytes of s.
    # Note that this function mallocs, so don't forget to free the result.
    n 1 + malloc
    s over n memcpy
    dup n + 0 castc swap setc


# LIST
# A dynamic list of 64-bit integers, with O(n) time complexity[1].
#
# [1] The Simple and Elegant Idea behind Efficient Dynamic Arrays
#     https://youtu.be/Ij7NQ-0mIVA

const list.capacity  0  # int
const list.len       8  # int
const list.items     16 # ptr

const LIST_METADATA_SIZE  16
const LIST_ITEM_SIZE      8


def list_create: int capacity -> ptr
    # Initializes an empty list with a given capacity and returns its pointer
    capacity LIST_ITEM_SIZE * LIST_METADATA_SIZE + malloc
    dup list.capacity + capacity swap seti
    dup list.len      + 0        swap seti


def new_list: -> ptr
    # Returns a pointer to an empty list
    1 list_create


def list_fetch: int index, ptr list -> int
    # Returns the value of a certain index in a given list
    list LIST_METADATA_SIZE + index LIST_ITEM_SIZE * + derefi


def list_pop: ptr list -> int
    # Removes and returns the last value of a given list
    list list.len + derefi 0 = if
        "Can't pop from an empty list" raise

    list list.len + derefi 1 -
    dup list list.len + seti
    LIST_ITEM_SIZE * list + LIST_METADATA_SIZE + derefi


def list_peek: ptr list -> int
    # Returns the last value of a given list
    list list.len + derefi 0 = if
        "Can't peek in an empty list" raise

    list list.len + derefi 1 - LIST_ITEM_SIZE * list + LIST_METADATA_SIZE + derefi


def list_append: int item, ptr list -> ptr
    # Appends an item to a given list and return a pointer to the list
    list list.len + derefi
    list list.capacity + derefi = if
        # Create a list with double the capacity
        list list.capacity + derefi 2 * list_create

        # Copy items
        list list.items +
        over list.items +
        list list.len + derefi LIST_ITEM_SIZE *
        memcpy

        # Update metadata
        list list.capacity + derefi 2 *
        over list.capacity + seti
        list list.len + derefi
        over list.len + seti

        # Free old list
        list free
    else
        list

    # Append item to list
    dup list.len + derefi
    dup 1 + rot dup rot swap list.len + seti swap
    LIST_ITEM_SIZE * LIST_METADATA_SIZE + over + item swap seti

def puti: int i -> void
    # Prints a number to STDOUT
    i 255 <= i 0 >= and if
        5 malloc
        dup i swap i8tohex
        dup puts
        free
    else
        19 malloc
        dup i swap i64tohex
        dup puts
        free

def errori: int i -> void
    # Prints a number to STDERR
    i 255 <= i 0 >= and if
        5 malloc
        dup i swap i8tohex
        dup error
        free
    else
        19 malloc
        dup i swap i64tohex
        dup error
        free
